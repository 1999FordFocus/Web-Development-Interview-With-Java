# Java基础问题

## 0、Java源码的编译过程？

源代码-> 词法分析器 -> 语法分析器 -> 语义分析器 -> 字节码生成器

## 0.1、jvm的作用？

保证Java一次编译到处运行，屏蔽了机器底层机器码。保证Java不面向任何的处理器而只是面向于虚拟机。

## 0.2、Java如何跳出多重循环？

```Java

```



## 1、Hash为什么要右移16位异或？

```Java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
 }
```

首先这个方法的返回值还是一个哈希值。为什么不直接返回`key.hashCode()`呢？还要与 (h >>> 16)异或。

先看一个例子：

```Java
h = key.hashcode() 1111 1101 1101 1111 0101 1101 0010 1111
^
h >>> 16           0000 0000 0000 0000 1111 1101 1101 1111
----------------------------------------------------------
h ^ (h >>> 16)     1111 1101 1101 1111 1010 0000 1111 0000
h = key.hashcode() 1111 1101 1101 1111 0101 1101 0010 1111  
```



对比`h = key.hashcode()` 与 `h ^ (h >>> 16)` 发现，将h无符号右移16为相当于将高区16位移动到了低区的16位，再与原`hashcode`做异或运算，**可以将高低位二进制特征混合起来**。例子中可以看出高区的16位并没有变化。低区的16位发  生了较大的变化。这样做的目的是什么呢？

我们计算出的hash值在后面会参与到元素index的计算中。计算公式为 hash & (length - 1)。

仔细观察上文不难发现，高区的16位很有可能会被数组槽位数的二进制码锁屏蔽，**如果我们不做刚才移位异或运算，那么在计算index时将丢失高区特征。如果**没有上面这个异或操作，假设里两个hash值只有高位一点点的差异，然后在计算index过程中还丢失了高位的信息，那么就计算出同一个index。这也是将性能做到极致的一种体现！！！

### 使用异或运算的原因？

 **异或运算能更平均的保留各部分的特征**，如果采用**&**运算计算出来的值会向1靠拢，采用**|**运算计算出来的值会向0靠拢

### 为什么槽位数必须使用2^n？

1. 为了让hash后的结果更加均匀

   如果 length = 17 那么 hash  & (17 - 1) 。16转化为二进制包含更多的0，这样一来计算会被更多的0屏蔽。

2. 便于扩容后的重新计算index。

### 为什么扩容时总是把capacity扩大为原来的2倍？

由于我们要维护hashmap的大小为2^n，这样就使得len-1的二进制中全部都是1。进行位运算时可以降低hash碰撞的出现。

### HashMap的负载因子为什么是0.75？

负载因子主要与扩容有关，如果将负载因子设置为1，空间利用的就更加充分了，但是这样一来**会增大hash碰撞**的出现，有些位置的链表会过长，不利于查找。如果设置的过小的话虽然降低了hash碰撞的发生，但是会频繁触发扩容机制。

所以为了折中，将负载因子设置为0.75是对空间与时间的取舍。

### HashMap的线程安全问题？

1.多线程的put操作可能导致元素丢失

2.put和get并发时可能导致get为null

- 线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。

3.jdk 1.7 中并发put导致的循环链表导致get出现死循环

- 发生在多线程并发resize的情况下可能会导致环形链表的出现。

### hashmap的哈希冲突可以通过用多个hash函数解决吗?

不能，只是能降低冲突的概率，完全解决冲突是不可能的。

### 解决hash冲突的方法？

**1.拉链法（链地址）：**

**2.线性探测法：**冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

**3.二次探测法：**冲突发生时，在表的左右进行跳跃式探测，比较灵活。
